import java.util.*;


/**
 * catch up and win
 **/
class Player {
static Maze m = new Maze();
    public static void main(String args[]) {
             


            char[][] grid = new char[10][10];
 ;
         
        Scanner in = new Scanner(System.in);
        int K = in.nextInt(); // representing after how many turns the sus man will make another move
        if (in.hasNextLine()) {
              in.nextLine();
              
        }
        for (int i = 0; i < 10; i++) {
            String s = in.nextLine(); // the map


            for(int b = 0; b<s.length(); b++){

             
                 grid[i][b] = s.charAt(b);
                 if(grid[i][b] == 'P'){
                     m.source.row=i;
                     m.source.col = b;
                 }

                

            }



        }
   
    m.grid = grid;
    
        // game loop
        while (true) {
            int eneY = in.nextInt(); // the sus man's coordinate,two integers separated by space in a single line
            int eneX = in.nextInt(); // the sus man's coordinate,two integers separated by space in a single line
            
    
       
       if(m.eneX != eneX || m.eneY!= eneY){
      
            m.eneX = eneX;
            m.eneY = eneY;
            
 m.minDistance();


       }


Character pozicija =  m.sledeciKoraci.get(0);
m.sledeciKoraci.remove(0);
    
    switch(pozicija){

        case 'U':
        m.source.row -= 1;
        
        break;
        case 'D':
        m.source.row += 1;
        break;
        case 'L':
        m.source.col -=1;
        break;
        case 'R':
        m.source.col +=1;
        break;
    }

    System.out.println(pozicija);
    System.err.println(m.sledeciKoraci.toString());
    System.err.println("A nalazim se na " + m.source.row + " i " + m.source.col);
         
        
  
   

        }


    }
}

//Location je klasa za poziciju, i pamcenje prethodnih cvorova za BFS rekonstrukciju puta

class Location {
  int row;
  int col;

  List<Character> putanja = new ArrayList<>(); //Pamti trenutni put do ovog ƒçvora



    public Location(int row, int col) 
  {
   
    this.row = row;
    this.col = col;

   
   
  }

    public Location(int row, int col,  List<Character> putanja) 
  {

   this.putanja = putanja;
 
    this.row = row;
    this.col = col;

  }


}

class Maze {

    char[][] grid;
    int eneX;
    int eneY;
    List<Character> sledeciKoraci = new ArrayList<>();
        Location source = new Location(0, 0);

          
public  int minDistance( )
  {



sledeciKoraci= new ArrayList<>();
        boolean[][] visited
      = new boolean[grid.length][grid[0].length];


    visited[source.row][source.col] = true;



    // zapocinjemo BFS od cvora 'P'
    Queue<Location> queue = new LinkedList<>();
    queue.add(new Location(source.row, source.col));

  

    while (queue.isEmpty() == false) {


      Location p = queue.remove();

    
      // gore
      if (isValid(p.row - 1, p.col, grid, visited)) {
          List<Character>temp = new ArrayList<Character>(p.putanja);
           temp.add('U');
        queue.add(new Location(p.row - 1, p.col,
                            temp ));
        visited[p.row - 1][p.col] = true;

       
      }

      // dole
      if (isValid(p.row + 1, p.col, grid, visited)) {
          List<Character>temp = new ArrayList<Character>(p.putanja);
          temp.add('D');
        queue.add(new Location(p.row + 1, p.col,
                             temp));
        visited[p.row + 1][p.col] = true;
     
        
      }

      // levo
      if (isValid(p.row, p.col - 1, grid, visited)) {
           List<Character>temp = new ArrayList<Character>(p.putanja);
            temp.add('L');
        queue.add(new Location(p.row, p.col - 1,
                            temp));
        visited[p.row][p.col - 1] = true;
        
     
   
      }

      // desno
      if (isValid(p.row, p.col + 1, grid,
                  visited)) {
            List<Character>temp = new ArrayList<Character>(p.putanja);
           temp.add('R');
        queue.add(new Location(p.row, p.col + 1,
                             temp));
        visited[p.row][p.col + 1] = true;
      
   
       
      }

        // neprijatelj pronadjen
      if (p.row == eneY && p.col == eneX){

             System.err.println(Arrays.deepToString(this.grid));
      
       
    sledeciKoraci = p.putanja;
        
   
      
        
   
        return 1;
      }
    }

    
    return -1;
  }

  // provera da li je polje zid ili van granica
  private boolean isValid(int x, int y,
                                 char[][] grid,
                                 boolean[][] visited)
  {
    if (x >= 0 && y >= 0 && x < grid.length
        && y < grid[0].length && grid[x][y] != '*'
        && visited[x][y] == false) {
      return true;
    }

    return false;
  }


public void obrisiPozicijuE(int x, int y){
    this.grid[x][y]  = '-';
}
}


