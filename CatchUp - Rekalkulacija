import java.util.*;


/**
 * catch up and win
 **/
class Player {
static Maze m = new Maze();
    public static void main(String args[]) {
             


            char[][] grid = new char[10][10];
 ;
         
        Scanner in = new Scanner(System.in);
        int K = in.nextInt(); // representing after how many turns the sus man will make another move
        if (in.hasNextLine()) {
              in.nextLine();
              
        }
        for (int i = 0; i < 10; i++) {
            String s = in.nextLine(); // the map


            for(int b = 0; b<s.length(); b++){

             
                 grid[i][b] = s.charAt(b);
                 if(grid[i][b] == 'P'){
                     m.source.row=i;
                     m.source.col = b;
                 }

                

            }



        }
   
    m.grid = grid;
    
        // game loop
        while (true) {
            int eneY = in.nextInt(); // the sus man's coordinate,two integers separated by space in a single line
            int eneX = in.nextInt(); // the sus man's coordinate,two integers separated by space in a single line
            
    
       
       if(m.eneX != eneX || m.eneY!= eneY){
      
            m.eneX = eneX;
            m.eneY = eneY;
            
 m.minDistance();


       }

       grid[m.source.row][m.source.col] = '-'; 

Character pozicija =  m.sledeciKoraci.get(0);
m.sledeciKoraci.remove(0);
    
    switch(pozicija){

        case 'U':
        m.source.row -= 1;
        
        break;
        case 'D':
        m.source.row += 1;
        break;
        case 'L':
        m.source.col -=1;
        break;
        case 'R':
        m.source.col +=1;
        break;
    }

    System.out.println(pozicija);
    System.err.println(m.sledeciKoraci.toString());
    System.err.println("A nalazim se na " + m.source.row + " i " + m.source.col);
         
        
       grid[m.source.row][m.source.col] = 'P'; 
   

        }


    }
}

//Predmet je klasa za poziciju, i pamcenje prethodnih cvorova za BFS rekonstrukciju puta

class Predmet {
  int row;
  int col;

  List<Character> putanja = new ArrayList<>(); //Pamti trenutni put do ovog ƒçvora



    public Predmet(int row, int col) 
  {
   
    this.row = row;
    this.col = col;

   
   
  }

    public Predmet(int row, int col,  List<Character> putanja) 
  {

   this.putanja = putanja;
 
    this.row = row;
    this.col = col;

  }


}

class Maze {

    char[][] grid;
    int eneX;
    int eneY;
    List<Character> sledeciKoraci = new ArrayList<>();
        Predmet source = new Predmet(0, 0);

          
public  int minDistance( )
  {



sledeciKoraci= new ArrayList<>();
        boolean[][] visited
      = new boolean[grid.length][grid[0].length];


    visited[source.row][source.col] = true;

    // Pratimo koja polja smo posetili

   
    for (int i = 0; i < grid.length; i++) {
      for (int j = 0; j < grid[i].length; j++)
      {
          
         if(grid[i][j]=='*'){       
             visited[i][j] = true;   //zidove obelezavamo kao posecena polja, kako ne bi smo isli na njih
         }
         
           if(grid[i][j]=='E'){  //brisemo prethdonu lokaciju protivnika
           grid[i][j]='-';
         }
         

      
      }
    }
 

     
     this.grid[eneY][eneX] = 'E'; // new target

    // zapocinjemo BFS od cvora 'P'
    Queue<Predmet> queue = new LinkedList<>();
    queue.add(new Predmet(source.row, source.col));

  

    while (queue.isEmpty() == false) {


      Predmet p = queue.remove();

    
      // gore
      if (isValid(p.row - 1, p.col, grid, visited)) {
          List<Character>temp = new ArrayList<Character>(p.putanja);
           temp.add('U');
        queue.add(new Predmet(p.row - 1, p.col,
                            temp ));
        visited[p.row - 1][p.col] = true;

       
      }

      // dole
      if (isValid(p.row + 1, p.col, grid, visited)) {
          List<Character>temp = new ArrayList<Character>(p.putanja);
          temp.add('D');
        queue.add(new Predmet(p.row + 1, p.col,
                             temp));
        visited[p.row + 1][p.col] = true;
     
        
      }

      // levo
      if (isValid(p.row, p.col - 1, grid, visited)) {
           List<Character>temp = new ArrayList<Character>(p.putanja);
            temp.add('L');
        queue.add(new Predmet(p.row, p.col - 1,
                            temp));
        visited[p.row][p.col - 1] = true;
        
     
   
      }

      // desno
      if (isValid(p.row, p.col + 1, grid,
                  visited)) {
            List<Character>temp = new ArrayList<Character>(p.putanja);
           temp.add('R');
        queue.add(new Predmet(p.row, p.col + 1,
                             temp));
        visited[p.row][p.col + 1] = true;
      
   
       
      }

        // neprijatelj pronadjen
      if (grid[p.row][p.col] == 'E'){
             System.err.println(Arrays.deepToString(this.grid));
      
       
    sledeciKoraci = p.putanja;
        
   
      
        
   
        return p.dist;
      }
    }

    
    return -1;
  }

  // provera da li je validno
  private boolean isValid(int x, int y,
                                 char[][] grid,
                                 boolean[][] visited)
  {
    if (x >= 0 && y >= 0 && x < grid.length
        && y < grid[0].length && grid[x][y] != '*'
        && visited[x][y] == false) {
      return true;
    }

    return false;
  }


public void obrisiPozicijuE(int x, int y){
    this.grid[x][y]  = '-';
}
}


